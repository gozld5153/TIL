# 모의고사

### 문제설명

수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.

- 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
- 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
- 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.

제한 조건

- 시험은 최대 10,000 문제로 구성되어있습니다.
- 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
- 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.

### 문제풀이

문제의 수만큼 수포자의 정답이 반복되어야 한다. 각 수포자들의 반복되는 패턴을 배열로 담는다. 1번 수포자의 경우 [1, 2, 3, 4, 5] 5의 길이를 갖는 배열이다. 문제 수를 배열의 길이로 나눈 나머지 값을 배열의 인덱스 값으로 하면 계속적인 반복이 가능하다. 배열의 인덱스이기 때문에 문제는 0번부터 시작하는 걸로 한다.  
이렇게 1번 2번 3번 수포자의 정답을 문제수만큼 늘려준 후 각 정답과 일치하는지 여부를 확인한다. 길이가 3이고 각요소는 0인 result라는 변수를 만든다 ex([0, 0, 0]) 이 배열의 인덱스는 각각의 수포자들을 의미하고 요소는 수포자들이 맞춘 정답 갯수를 의미한다.  
가장 많이 맞춘 사람을 리턴해야 하므로 result의 값중에서 가장 큰 값을 찾아 max라는 변수에 담는다. 이 값을 가지고 result의 길이만큼 반복문을 돌려서 max와 result의 요소중에 같은 값이 있는지를 찾고 일치하면 answer라는 배열에 해당 result 인덱스 + 1을 해줌으로써 가장 많이 맞춘 수포자를 리턴한다.

```js
function solution(answers) {
  let one = [1, 2, 3, 4, 5];
  let two = [2, 1, 2, 3, 2, 4, 2, 5];
  let three = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];
  let result = [0, 0, 0];
  let answer = [];

  //문제수만큼 반복문을 돌린다.
  for (let i = 0; i < answers.length; i++) {
    //수포자의 정답 패턴보다 문제수가 많아서 수포자의 패턴이 없다면 다음 패턴을 넣어준다.
    if (!one[i]) one.push((i % 5) + 1);
    if (!two[i]) two.push(two[i % 8]);
    if (!three[i]) three.push(three[i % 10]);
    //수포자의 답과 문제의 정답이 맞는지 확인 후 결과에 집어넣는다.
    if (one[i] === answers[i]) result[0] += 1;
    if (two[i] === answers[i]) result[1] += 1;
    if (three[i] === answers[i]) result[2] += 1;
  }
  //가장 많이 맞힌 수를 구한다.
  let max = Math.max(...result);
  for (let i = 0; i < result.length; i++) {
    //result 요소와 max값이 일치하면 가장 많이 맞힌 사람이다.
    // 인덱스 + 1을 통해 몇 번째 수포자인지 알 수 있다.
    if (max === result[i]) answer.push(i + 1);
  }
  return answer;
}
```
