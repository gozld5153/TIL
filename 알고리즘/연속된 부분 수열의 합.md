# 없는 숫자 더하기 - 프로그래머스

#### 문제 설명

비내림차순으로 정렬된 수열이 주어질 때, 다음 조건을 만족하는 부분 수열을 찾으려고 합니다.

기존 수열에서 임의의 두 인덱스의 원소와 그 사이의 원소를 모두 포함하는 부분 수열이어야 합니다.
부분 수열의 합은 k입니다.
합이 k인 부분 수열이 여러 개인 경우 길이가 짧은 수열을 찾습니다.
길이가 짧은 수열이 여러 개인 경우 앞쪽(시작 인덱스가 작은)에 나오는 수열을 찾습니다.
수열을 나타내는 정수 배열 sequence와 부분 수열의 합을 나타내는 정수 k가 매개변수로 주어질 때, 위 조건을 만족하는 부분 수열의 시작 인덱스와 마지막 인덱스를 배열에 담아 return 하는 solution 함수를 완성해주세요. 이때 수열의 인덱스는 0부터 시작합니다.

제한사항
5 ≤ sequence의 길이 ≤ 1,000,000
1 ≤ sequence의 원소 ≤ 1,000
sequence는 비내림차순으로 정렬되어 있습니다.
5 ≤ k ≤ 1,000,000,000
k는 항상 sequence의 부분 수열로 만들 수 있는 값입니다.

#### 문제 풀이

이 문제는 투 포인터(Two Pointer) 알고리즘을 이용해서 풀 수 있습니다. 투 포인터 알고리즘은 정렬된 배열에서 두 개의 포인터를 이용해서 원하는 조건을 만족하는 부분 배열을 찾는 방법입니다.

우선, 부분 수열의 길이가 최소가 되어야 하므로, 가능한 짧은 부분 수열부터 찾아야 합니다. 따라서, 부분 수열의 길이를 2부터 sequence의 길이까지 하나씩 증가시키면서 투 포인터 알고리즘을 이용해서 부분 수열의 합이 k인 부분 수열을 찾습니다.

투 포인터 알고리즘을 이용하기 위해서, 배열에서 연속된 부분 배열의 합을 구하는 방법이 필요합니다. 이를 위해서는 먼저 배열의 누적 합(prefix sum)을 계산해야 합니다. prefix sum을 이용하면, 배열의 i번째 원소까지의 합을 O(1) 시간에 계산할 수 있습니다.

이제, 투 포인터 알고리즘을 이용해서 부분 수열의 합이 k인 부분 수열을 찾습니다. left와 right라는 두 개의 포인터를 이용해서 부분 수열의 합을 구합니다. left는 부분 수열의 시작 인덱스, right는 부분 수열의 끝 인덱스를 가리키는 포인터입니다. left와 right가 가리키는 구간의 합이 k보다 작으면, right를 하나씩 증가시킵니다. 합이 k보다 크면, left를 하나씩 증가시킵니다. 이를 반복해서 부분 수열의 합이 k인 부분 수열을 찾으면, 이 부분 수열의 시작 인덱스와 끝 인덱스를 배열에 담아서 반환합니다.

아래는 구현된 코드입니다. 시간 복잡도는 O(n)입니다.

```js
function solution(sequence, k) {
  let answer = [];
  const prefix = new Array(sequence.length + 1).fill(0);
  for (let i = 1; i <= sequence.length; i++) {
    prefix[i] = prefix[i - 1] + sequence[i - 1];
  }

  let start = 0,
    end = 0;
  let max = 1000001;

  while (end <= sequence.length) {
    if (prefix[end + 1] - prefix[start] === k) {
      if (end + 1 - start < max) {
        max = end + 1 - start;
        answer = [start, end];
      }
      end++;
    } else if (prefix[end + 1] - prefix[start] > k) start++;
    else end++;
  }

  return answer;
}
```
